default_platform(:ios)

# App Store Connect API Key (shared across projects)
API_KEY_PATH = File.expand_path("~/.appstoreconnect/private_keys/AuthKey_KN4CQZ4P8G.p8")

def api_key
  app_store_connect_api_key(
    key_id: "KN4CQZ4P8G",
    issuer_id: "52d3d37b-494c-4d95-afee-3272957150c7",
    key_filepath: API_KEY_PATH,
    in_house: false
  )
end

platform :ios do
  before_all do
    unless File.exist?(API_KEY_PATH)
      UI.user_error!("AuthKey not found at #{API_KEY_PATH}. Download from App Store Connect > Users > Keys")
    end
  end

  # ==================== MATCH ====================

  desc "Setup all certificates and profiles (development, adhoc, appstore)"
  lane :setup_match do
    UI.important("ðŸ”§ GÃ©nÃ©ration des certificats Development...")
    match(type: "development", force: true, force_for_new_devices: true)

    UI.important("ðŸ”§ GÃ©nÃ©ration des certificats AdHoc...")
    match(type: "adhoc", force: true, force_for_new_devices: true)

    UI.important("ðŸ”§ GÃ©nÃ©ration des certificats App Store...")
    match(type: "appstore", force: true, force_for_new_devices: true)

    UI.success("âœ… Tous les certificats et profils ont Ã©tÃ© crÃ©Ã©s avec succÃ¨s!")
  end

  desc "Clean and regenerate all certificates and profiles"
  lane :regenerate_certificates do
    UI.important("ðŸ—‘ï¸  Suppression des certificats et profils...")
    match_nuke(type: "development", skip_confirmation: true)
    match_nuke(type: "adhoc", skip_confirmation: true)
    match_nuke(type: "appstore", skip_confirmation: true)

    UI.success("âœ… Anciens certificats supprimÃ©s, rÃ©gÃ©nÃ©ration...")
    setup_match
  end

  # ==================== BETA ====================

  desc "Push a new build to TestFlight"
  lane :beta do |options|
    # Ensure we're on main and git is clean FIRST
    ensure_git_branch(branch: "main")
    ensure_git_status_clean

    # Pull latest changes
    sh("git pull origin main")

    # Version bump if requested (bump: "major", "minor", or "patch")
    new_version = nil
    if options[:bump]
      current_version = get_version_number(xcodeproj: "trailmark.xcodeproj", target: "trailmark")
      version_parts = current_version.split('.')
      major = version_parts[0].to_i
      minor = version_parts[1]&.to_i || 0
      patch = version_parts[2]&.to_i || 0

      case options[:bump]
      when "major"
        major += 1
        minor = 0
        patch = 0
      when "minor"
        minor += 1
        patch = 0
      when "patch"
        patch += 1
      else
        UI.user_error!("Invalid bump type: #{options[:bump]}. Use 'major', 'minor', or 'patch'")
      end

      new_version = "#{major}.#{minor}.#{patch}"
      increment_version_number(xcodeproj: "trailmark.xcodeproj", version_number: new_version)
      UI.success("âœ… Version incrÃ©mentÃ©e de #{current_version} Ã  #{new_version}")
    else
      new_version = get_version_number(xcodeproj: "trailmark.xcodeproj", target: "trailmark")
    end

    # Setup certificates and provisioning profiles
    match(type: "appstore", api_key: api_key, readonly: is_ci, verbose: true)

    # Get latest TestFlight build number and increment
    latest_build = latest_testflight_build_number(
      api_key: api_key,
      app_identifier: CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier),
      initial_build_number: 0
    )
    new_build = latest_build + 1

    # Update build number directly in pbxproj (project uses GENERATE_INFOPLIST_FILE)
    UI.message("ðŸ“ Mise Ã  jour du build number Ã  #{new_build}...")
    sh("sed -i '' 's/CURRENT_PROJECT_VERSION = [0-9]*;/CURRENT_PROJECT_VERSION = #{new_build};/g' ../trailmark.xcodeproj/project.pbxproj")

    # Clear Xcode derived data to ensure build number is picked up
    UI.message("ðŸ§¹ Nettoyage du cache Xcode...")
    clear_derived_data

    # Build the app (pass build number explicitly to avoid cache issues)
    build_app(
      scheme: "trailmark",
      project: "trailmark.xcodeproj",
      clean: true,
      output_directory: "./fastlane/builds",
      output_name: "trailmark",
      export_method: "app-store",
      xcargs: "-skipMacroValidation -skipPackagePluginValidation",
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier) => "match AppStore #{CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)}"
        }
      }
    )

    # Get changelog from last commit body
    changelog = sh("git log -1 --pretty=%b").strip
    if changelog.empty?
      changelog = "Corrections de bugs et amÃ©liorations des performances"
      UI.important("âš ï¸  Aucune description de commit trouvÃ©e, utilisation du changelog par dÃ©faut")
    end

    # Upload to TestFlight
    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: true,
      skip_submission: true,
      distribute_external: false,
      notify_external_testers: false,
      changelog: changelog
    )

    # Commit version and build number changes
    commit_version_bump(
      message: "Bump version to #{new_version} build #{new_build} [skip ci]",
      xcodeproj: "trailmark.xcodeproj",
      include: ["Info.plist"],
      force: true
    )

    # Create version tag (vX.Y.Z format)
    version_tag = "v#{new_version}"
    add_git_tag(tag: version_tag)

    # Create release branch
    release_branch = "release/#{new_version}"
    sh("git checkout -b #{release_branch}")
    sh("git checkout main")

    # Push everything: main, release branch, and tags
    push_to_git_remote(tags: true)
    sh("git push origin #{release_branch}")

    UI.success("ðŸŽ‰ Release #{version_tag} crÃ©Ã©e et uploadÃ©e sur TestFlight!")
    UI.success("   ðŸ“¦ Version: #{new_version} (build #{new_build})")
    UI.success("   ðŸ·ï¸  Tag: #{version_tag}")
    UI.success("   ðŸŒ¿ Branche: #{release_branch}")
  end

  # ==================== OTHER LANES ====================

  desc "Push to TestFlight without version bump (rebuild)"
  lane :beta_no_bump do
    match(type: "appstore", api_key: api_key, readonly: true)

    build_app(
      scheme: "trailmark",
      project: "trailmark.xcodeproj",
      clean: true,
      output_directory: "./fastlane/builds",
      export_method: "app-store",
      xcargs: "-skipMacroValidation -skipPackagePluginValidation",
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier) => "match AppStore #{CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)}"
        }
      }
    )

    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: true
    )
  end

  desc "Build app for release (without upload)"
  lane :build do
    match(type: "appstore", api_key: api_key, readonly: true)

    increment_build_number(xcodeproj: "trailmark.xcodeproj")

    build_app(
      scheme: "trailmark",
      project: "trailmark.xcodeproj",
      export_method: "app-store",
      xcargs: "-skipMacroValidation -skipPackagePluginValidation",
      output_directory: "./fastlane/builds"
    )
  end

  desc "Run tests"
  lane :test do
    run_tests(
      project: "trailmark.xcodeproj",
      scheme: "trailmark",
      device: "iPhone 16"
    )
  end
end
