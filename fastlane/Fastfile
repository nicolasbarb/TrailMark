default_platform(:ios)

# App Store Connect API Key (shared across projects)
API_KEY_PATH = File.expand_path("~/.appstoreconnect/private_keys/AuthKey_KN4CQZ4P8G.p8")

def api_key
  app_store_connect_api_key(
    key_id: "KN4CQZ4P8G",
    issuer_id: "52d3d37b-494c-4d95-afee-3272957150c7",
    key_filepath: API_KEY_PATH,
    in_house: false
  )
end

platform :ios do
  before_all do
    unless File.exist?(API_KEY_PATH)
      UI.user_error!("AuthKey not found at #{API_KEY_PATH}. Download from App Store Connect > Users > Keys")
    end
    # Workaround for Xcode 26 altool bug (fastlane/fastlane#29739)
    ENV["DELIVER_ALTOOL_ADDITIONAL_UPLOAD_PARAMETERS"] = "--use-old-altool"
  end

  # ==================== MATCH ====================

  desc "Setup all certificates and profiles (development, adhoc, appstore)"
  lane :setup_match do
    UI.important("ðŸ”§ GÃ©nÃ©ration des certificats Development...")
    match(type: "development", force: true, force_for_new_devices: true)

    UI.important("ðŸ”§ GÃ©nÃ©ration des certificats AdHoc...")
    match(type: "adhoc", force: true, force_for_new_devices: true)

    UI.important("ðŸ”§ GÃ©nÃ©ration des certificats App Store...")
    match(type: "appstore", force: true, force_for_new_devices: true)

    UI.success("âœ… Tous les certificats et profils ont Ã©tÃ© crÃ©Ã©s avec succÃ¨s!")
  end

  desc "Clean and regenerate all certificates and profiles"
  lane :regenerate_certificates do
    UI.important("ðŸ—‘ï¸  Suppression des certificats et profils...")
    match_nuke(type: "development", skip_confirmation: true)
    match_nuke(type: "adhoc", skip_confirmation: true)
    match_nuke(type: "appstore", skip_confirmation: true)

    UI.success("âœ… Anciens certificats supprimÃ©s, rÃ©gÃ©nÃ©ration...")
    setup_match
  end

  # ==================== BETA ====================

  desc "Push a new build to TestFlight"
  lane :beta do |options|
    # Increment version if bump parameter is provided
    if options[:bump]
      current_version = get_version_number(
        xcodeproj: "trailmark.xcodeproj",
        target: "trailmark"
      )

      version_parts = current_version.split('.')
      major = version_parts[0].to_i
      minor = version_parts[1]&.to_i || 0
      patch = version_parts[2]&.to_i || 0

      case options[:bump]
      when "major"
        major += 1
        minor = 0
        patch = 0
      when "minor"
        minor += 1
        patch = 0
      when "patch"
        patch += 1
      end

      new_version = "#{major}.#{minor}.#{patch}"

      increment_version_number(
        xcodeproj: "trailmark.xcodeproj",
        version_number: new_version
      )

      UI.success("âœ… Version incrÃ©mentÃ©e de #{current_version} Ã  #{new_version}")
    end

    # Setup App Store Connect API Key
    api_key = app_store_connect_api_key(
      key_id: "KN4CQZ4P8G",
      issuer_id: "52d3d37b-494c-4d95-afee-3272957150c7",
      key_filepath: File.expand_path("~/.appstoreconnect/private_keys/AuthKey_KN4CQZ4P8G.p8"),
      in_house: false
    )

    # Setup certificates and provisioning profiles
    match(
      type: "appstore",
      api_key: api_key,
      readonly: is_ci,
      verbose: true
    )

    # Get latest TestFlight build number to avoid conflicts
    latest_testflight_build_number = latest_testflight_build_number(
      api_key: api_key,
      app_identifier: CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier),
      initial_build_number: 0
    )

    # Increment build number (based on TestFlight)
    increment_build_number(
      xcodeproj: "trailmark.xcodeproj",
      build_number: latest_testflight_build_number + 1
    )

    # Build the app using gym
    build_app(
      scheme: "trailmark",
      project: "trailmark.xcodeproj",
      clean: true,
      output_directory: "./fastlane/builds",
      output_name: "trailmark",
      export_method: "app-store",
      xcargs: "-skipMacroValidation -skipPackagePluginValidation",
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier) => "match AppStore #{CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)}"
        }
      }
    )

    # Get changelog from last commit body (description only, not the title)
    changelog = sh("git log -1 --pretty=%b").strip

    # Use default message if commit body is empty
    if changelog.empty?
      changelog = "Corrections de bugs et amÃ©liorations des performances"
      UI.important("âš ï¸  Aucune description de commit trouvÃ©e, utilisation du changelog par dÃ©faut")
    end

    # Upload to TestFlight
    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: true,
      skip_submission: true,
      distribute_external: false,
      notify_external_testers: false,
      changelog: changelog
    )

    # Commit version and build number changes
    commit_version_bump(
      message: "Bump version to #{get_version_number(xcodeproj: 'trailmark.xcodeproj')} build #{lane_context[SharedValues::BUILD_NUMBER]} [skip ci]",
      xcodeproj: "trailmark.xcodeproj",
      force: true
    )

    # Tag release
    add_git_tag(
      tag: "testflight/#{get_version_number(xcodeproj: 'trailmark.xcodeproj')}/#{lane_context[SharedValues::BUILD_NUMBER]}"
    )

    # Push to remote
    push_to_git_remote
  end

  # ==================== OTHER LANES ====================

  desc "Push to TestFlight without version bump (rebuild with new build number)"
  lane :beta_no_bump do
    match(type: "appstore", api_key: api_key, readonly: true)

    # Get latest TestFlight build number to guarantee we're always higher
    latest_build = latest_testflight_build_number(
      api_key: api_key,
      app_identifier: CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier),
      initial_build_number: 0
    )
    new_build = latest_build + 1
    UI.message("ðŸ“¦ TestFlight latest build: #{latest_build}, building: #{new_build}")

    increment_build_number(
      xcodeproj: "trailmark.xcodeproj",
      build_number: new_build
    )

    clear_derived_data(derived_data_path: "~/Library/Developer/Xcode/DerivedData")

    build_app(
      scheme: "trailmark",
      project: "trailmark.xcodeproj",
      clean: true,
      output_directory: "./fastlane/builds",
      export_method: "app-store",
      xcargs: "-skipMacroValidation -skipPackagePluginValidation CURRENT_PROJECT_VERSION=#{new_build}",
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier) => "match AppStore #{CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)}"
        }
      }
    )

    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: true
    )

    UI.success("âœ… Build #{new_build} uploaded successfully!")
  end

  desc "Build app for release (without upload)"
  lane :build do
    match(type: "appstore", api_key: api_key, readonly: true)

    # Get latest TestFlight build number + 1
    latest_build = latest_testflight_build_number(
      api_key: api_key,
      app_identifier: CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier),
      initial_build_number: 0
    )
    new_build = latest_build + 1

    increment_build_number(
      xcodeproj: "trailmark.xcodeproj",
      build_number: new_build
    )

    clear_derived_data(derived_data_path: "~/Library/Developer/Xcode/DerivedData")

    build_app(
      scheme: "trailmark",
      project: "trailmark.xcodeproj",
      clean: true,
      export_method: "app-store",
      xcargs: "-skipMacroValidation -skipPackagePluginValidation CURRENT_PROJECT_VERSION=#{new_build}",
      output_directory: "./fastlane/builds"
    )

    UI.success("âœ… Built version #{get_version_number(xcodeproj: 'trailmark.xcodeproj')} (build #{new_build})")
  end

  desc "Run tests"
  lane :test do
    run_tests(
      project: "trailmark.xcodeproj",
      scheme: "trailmark",
      device: "iPhone 16"
    )
  end
end
